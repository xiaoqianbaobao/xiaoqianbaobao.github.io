<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DDIA第五章 | Qian&#39;s Blog</title>
<meta name="keywords" content="数据密集型系统设计">
<meta name="description" content="第五章：数据复制 复制的目的： ● 使得数据与用户在地理上接近（从而减少延迟） ● 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性） ● 伸缩">
<meta name="author" content="
作者:&nbsp;ShengQian">
<link rel="canonical" href="https://csqread.top/posts/tech/ddia%E7%AC%AC%E4%BA%94%E7%AB%A0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d056c2d8b86c8da0db95897f49066a3a22d796d21ff6173ef98b613234e402fe.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://csqread.top/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://csqread.top/img/%21.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://csqread.top/img/%21.jpg">
<link rel="apple-touch-icon" href="https://csqread.top/%21.jpg">
<link rel="mask-icon" href="https://csqread.top/%21.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="DDIA第五章" />
<meta property="og:description" content="第五章：数据复制 复制的目的： ● 使得数据与用户在地理上接近（从而减少延迟） ● 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性） ● 伸缩" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://csqread.top/posts/tech/ddia%E7%AC%AC%E4%BA%94%E7%AB%A0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-20T21:18:15+08:00" />
<meta property="article:modified_time" content="2023-09-20T21:18:15+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DDIA第五章"/>
<meta name="twitter:description" content="第五章：数据复制 复制的目的： ● 使得数据与用户在地理上接近（从而减少延迟） ● 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性） ● 伸缩"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://csqread.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "技术",
      "item": "https://csqread.top/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "DDIA第五章",
      "item": "https://csqread.top/posts/tech/ddia%E7%AC%AC%E4%BA%94%E7%AB%A0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DDIA第五章",
  "name": "DDIA第五章",
  "description": "第五章：数据复制 复制的目的： ● 使得数据与用户在地理上接近（从而减少延迟） ● 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性） ● 伸缩",
  "keywords": [
    "数据密集型系统设计"
  ],
  "articleBody": "第五章：数据复制 复制的目的：\n● 使得数据与用户在地理上接近（从而减少延迟）\n● 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）\n● 伸缩可以接受读请求的机器数量（从而提高读取吞吐量）\n如果复制的数据不会随时间而改变，那复制就很简单：复制一次即可。 复制的难点在于复制数据的变更。 三种流行的变更复制算法：\n● 单领导者\n● 多领导者\n● 无领导者\n复制时的权衡：使用同步复制还是异步复制？如何处理失败的副本？\n领导者与追随者 ● 存储数据库副本的每个节点称为 副本（replica）。\n● 多副本的问题：如何确保数据都落在了所有的副本上。\n○ 每次对数据库的写入都要传播到所有副本上，否则副本就会有不一样的数据。\n○ 常见的解决方案：基于领导者的复制（主从复制）。 主从复制工作原理：\n副本之一被指定为领导者（leader，也被称作主库）\na. 客户端写数据时，要把请求发送给领导者； b. 领导者把新输入写入本地存储。 2. 其他副本被称为追随者（followers，也被称作只读副本、从库、热备） a. 每当领导者将新数据写入本地存储时，他会把数据变更发送给所有的追随者，称之为复制日志或变更流。 b. 每个追随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。 3. 当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。 但只有领导者才能接受写操作（从客户端的角度来看从库都是只读的）。 同步复制与异步复制 复制系统的一个重要细节是：复制是 同步（synchronously） 发生还是 异步（asynchronously） 发生。 以用户更新头像为例： ● 从库 1 的复制是同步的 ● 从库 2 的复制是异步的\n同步复制： ● 优点：从库保证和主库一直的最新数据副本 ● 缺点：如果从库没有响应（如已崩溃、网络故障），主库就无法处理写入操作。主库必须阻止所有的写入，等待副本再次可用。\n半同步：通常使用一个从库与主库是同步的，而其他从库是异步的。这保证了至少两个节点拥有最新的数据副本。\n通常情况下，基于领导者的复制都配置为完全异步。注意，主库故障可能导致丢失数据。\n设置新从库 有时会增加一个新的从库。\n过程：\n在某个时刻获取主库的一致性快照（如果可能），而不必锁定整个数据库。大多数数据库都具有这个功能，因为它是备份必需的。对于某些场景，可能需要第三方工具，例如MySQL的innobackupex 。 将快照复制到新的从库节点。 从库连接到主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。该位置有不同的名称：例如，PostgreSQL将其称为 日志序列号（log sequence number, LSN），MySQL将其称为 二进制日志坐标（binlog coordinates）。 当从库处理完快照之后积压的数据变更，我们说它 赶上（caught up） 了主库。现在它可以继续处理主库产生的数据变化了。 处理节点宕机 我们的目标：即使个别节点失效，也要能保持整个系统运行，并尽可能控制节点停机带来的影响。\n从库失效：追赶恢复 ● 从库可以从日志知道，在发生故障前处理的最后一个事务。 ● 所以从库可以连接到主库，并拉取断开连接后的所有数据变更。 ● 应用完成所有变更之后，它就赶上了主库，继续接收数据变更流。\n主库失效：故障切换 ● 故障切换：需要把一个从库提升为新的主库，重新配置客户端，其他从库需要开始拉取来自新主库的变更。 ● 故障切换可以手动或者自动进行。\n自动故障切换：\n确认主库失效。有很多事情可能会出错：崩溃，停电，网络问题等等。没有万无一失的方法来检测出现了什么问题，所以大多数系统只是简单使用 超时（Timeout） ：节点频繁地相互来回传递消息，并且如果一个节点在一段时间内（例如30秒）没有响应，就认为它挂了（因为计划内维护而故意关闭主库不算）。 选择一个新的主库。这可以通过选举过程（主库由剩余副本以多数选举产生）来完成，或者可以由之前选定的控制器节点（controller node） 来指定新的主库。主库的最佳人选通常是拥有旧主库最新数据副本的从库（最小化数据损失）。让所有的节点同意一个新的领导者，是一个共识问题，将在第九章详细讨论。 重新配置系统以启用新的主库。客户端现在需要将它们的写请求发送给新主库（将在“请求路由”中讨论这个问题）。如果老领导回来，可能仍然认为自己是主库，没有意识到其他副本已经让它下台了。系统需要确保老领导认可新领导，成为一个从库。 故障切换会出现很多大麻烦：\n● 如果使用异步复制，则新主库可能没有收到老主库宕机前最后的写入操作。在选出新主库后，如果老主库重新加入集群，新主库在此期间可能会收到冲突的写入，那这些写入该如何处理？最常见的解决方案是简单丢弃老主库未复制的写入，这很可能打破客户对于数据持久性的期望。 ● 如果数据库需要和其他外部存储相协调，那么丢弃写入内容是极其危险的操作。例如在GitHub 【13】的一场事故中，一个过时的MySQL从库被提升为主库。数据库使用自增ID作为主键，因为新主库的计数器落后于老主库的计数器，所以新主库重新分配了一些已经被老主库分配掉的ID作为主键。这些主键也在Redis中使用，主键重用使得MySQL和Redis中数据产生不一致，最后导致一些私有数据泄漏到错误的用户手中。 ● 发生某些故障时（见第八章）可能会出现两个节点都以为自己是主库的情况。这种情况称为 脑裂(split brain)，非常危险：如果两个主库都可以接受写操作，却没有冲突解决机制（请参阅“多主复制”），那么数据就可能丢失或损坏。一些系统采取了安全防范措施：当检测到两个主库节点同时存在时会关闭其中一个节点[1]，但设计粗糙的机制可能最后会导致两个节点都被关闭【14】。 ● 主库被宣告死亡之前的正确超时应该怎么配置？在主库失效的情况下，超时时间越长，意味着恢复时间也越长。但是如果超时设置太短，又可能会出现不必要的故障切换。例如，临时负载峰值可能导致节点的响应时间超时，或网络故障可能导致数据包延迟。如果系统已经处于高负载或网络问题的困扰之中，那么不必要的故障切换可能会让情况变得更糟糕。\n复制日志的实现 基于主库的复制，底层工作有几种不同的复制方式。\n基于语句的复制 在最简单的情况下，主库记录下它执行的每个写入请求（语句（statement））并将该语句日志发送给其从库。 问题： ● 任何调用 非确定性函数（nondeterministic） 的语句，可能会在每个副本上生成不同的值。比如 NOW(), RAND()。 ● 如果语句使用了自增列（auto increment），或者依赖于数据库中的现有数据（例如，UPDATE … WHERE \u003c某些条件\u003e），则必须在每个副本上按照完全相同的顺序执行它们，否则可能会产生不同的效果。影响并发。 ● 有副作用的语句（例如，触发器，存储过程，用户定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定的。\n传输预写式日志（WAL） 第三章告诉我们，写操作通常追加到日志中： ● 对于日志结构存储引擎（SSTables 和 LSM 树），日志是主要存储位置。日志段在后台压缩，并进行垃圾回收。 ● 覆盖单个磁盘块的 B 树，每次修改会先写入预写式日志（Write Ahead Log, WAL），以便崩溃后索引可以恢复到一个一致的状态。 所以，日志都是包含所有数据库写入的仅追加字节序列。可以使用完全相同的日志在另一个节点上构建副本：主库把日志发送给从库。 PostgreSQL和Oracle等使用这种复制方法。 缺点： ● 复制与存储引擎紧密耦合。 ● 不可能使主库和从库上运行不同版本的数据库软件。 ● 运维时如果升级软件版本，有可能会要求停机。\n逻辑日志复制（基于行） 采用逻辑日志，可以把复制与存储逻辑分离。 关系型数据库通常以行作为粒度描述数据库写入的记录序列： ● 对于插入的行，日志包含所有列的新值； ● 对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，或者所有列的旧值。 ● 对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列（至少是更新列）的新值。 优点： ● 逻辑日志与存储引擎分离，方便向后兼容。可以让领导者和跟随者运行不同版本的数据库软件。 ● 对于外部应用，逻辑日志也更容易解析。比如复制到数据仓库，或者自定义索引和缓存。被称为数据变更捕获。\n基于触发器的复制 ● 上述复制都是数据库自己实现的。也可以自定义复制方法：数据库提供了触发器和存储过程。 ● 允许数据库变更时，自动执行应用的程序代码。 ● 开销更大，更容易出错。但更灵活。\n复制延迟问题 ● 主从异步同步会有延迟：导致同时对主库和从库的查询，结果可能不同。 ● 因为从库会赶上主库，所以上述效应被称为「最终一致性」。 ● 复制延迟可能超过几秒或者几分钟，下文是 3 个例子。\n读己之写 如果用户把数据提交到了主库，但是主从有延迟，用户马上看数据的时候请求的从库，会感觉到数据丢失。\n此时需要「读写一致性」，也成为读己之写一致性。 技术： ● 读用户可能已经修改过的内容时，都从主库读；比如读个人资料都从主库读，读别人的资料可以读从库。 ● 如果应用的部分内容都可能被用户编辑，上述方法无效。可以指定更新后的时间窗口，比如上次更新的一分钟内从主库读。 ● 客户端记住最近一次写入的时间戳，从库提供查询时，保证该时间戳前的变更都已经传播到了本从库；否则从另外的从库读，或者等待从库追赶上来。（时间戳可以是逻辑时间戳，如日志序列号；或者要有准确的时间同步） ● 如果副本在多个数据中心，则比较复杂。任何需要从领导者提供服务的请求，都必须路由到包含主库的数据中心。 用户有多个设备时，还要考虑的问题： ● 记录更新时间戳变得更困难； ● 不同设备可能路由到不同的数据中心。如果你的方法需要读主库，就需要把同一用户的请求路由到同一个数据中心。\n单调读 用户可能会遇到时光倒流。 第一次请求到从库看到了评论，第二次请求到另外一个从库发现评论消失。\n单调读保证了这种异常不会发生。 方法： ● 确保每个用户总是从同一副本来读取。比如基于用户 ID 的散列来选择副本，而不是随机选。 ● 但是如果该副本失败，则需要路由到另一个副本。\n一致前缀读 一系列事件可能出现前后顺序不一致问题。比如回答可能在提问之前发生。 这是分区（分片）数据库中的一个特殊问题：不同分区之间独立，不存在全局写入顺序。\n需要「一致前缀读」。 方法： ● 任何因果相关的写入都写入相同的分区。\n复制延迟的解决方案 ● 可以信赖数据库：需要事务。 ● 事务（transaction） 存在的原因：数据库通过事务提供强大的保证，所以应用程序可以更加简单。 ● 单节点事务存在了很长时间，但是分布式数据库中，许多系统放弃了事务。“因为事务的代价太高。” ● 本书的其余部分将继续探讨事务。\n",
  "wordCount" : "4296",
  "inLanguage": "zh",
  "datePublished": "2023-09-20T21:18:15+08:00",
  "dateModified": "2023-09-20T21:18:15+08:00",
  "author":[{
    "@type": "Person",
    "name": "ShengQian"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://csqread.top/posts/tech/ddia%E7%AC%AC%E4%BA%94%E7%AB%A0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Qian's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://csqread.top/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://csqread.top" accesskey="h" title="Qian&#39;s Blog (Alt + H)">
                <img src="https://csqread.top/img/%21.jpg" alt="" aria-label="logo"
                    height="35">Qian&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://csqread.top/search" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://csqread.top/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://csqread.top/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://csqread.top/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://csqread.top/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://csqread.top/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://csqread.top/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://csqread.top">主页</a>&nbsp;»&nbsp;<a href="https://csqread.top/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://csqread.top/posts/tech/">技术</a></div>
    <h1 class="post-title">
      DDIA第五章
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2023-09-20 21:18:15 +0800 CST'>2023-09-20</span>&nbsp;|&nbsp;更新:&nbsp;2023-09-20&nbsp;|&nbsp;字数:&nbsp;4296字&nbsp;|&nbsp;时长: 9分钟&nbsp;|&nbsp;
作者:&nbsp;ShengQian


    &nbsp;|&nbsp;标签: &nbsp;
    <ul class="post-tags-meta">
        <a href="https://csqread.top/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">数据密集型系统设计</a>
    </ul>

    
    
    
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_page_pv">
        &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
    </span>

    
    
    
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.11/twikoo.all.min.js">
    </script>
    <script>
        let url = document.documentURI
        
        let dnsUrl = "https://csqread.top"
        let urlSplit = url.split(dnsUrl)
        let finalUrl = urlSplit[1]
        if (finalUrl[0] !== '/') {
            finalUrl = '/'+finalUrl
        }
        twikoo.getCommentsCount({
            envId:  null ,
            region:  null ,
            urls: [
                finalUrl,
            ],
            includeReply: false 
        }).then(function (res) {
            let count = res[0].count
            const obj = document.getElementById("comment_count");
            obj.innerText = count
            
            
            
        }).catch(function (err) {
            
            console.error(err);
        });
    </script>
    &nbsp;| 评论: &nbsp; <span id="comment_count"></span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%ac%ac%e4%ba%94%e7%ab%a0%e6%95%b0%e6%8d%ae%e5%a4%8d%e5%88%b6" aria-label="第五章：数据复制">第五章：数据复制</a><ul>
                            
                    <li>
                        <a href="#%e9%a2%86%e5%af%bc%e8%80%85%e4%b8%8e%e8%bf%bd%e9%9a%8f%e8%80%85" aria-label="领导者与追随者">领导者与追随者</a><ul>
                            
                    <li>
                        <a href="#%e5%90%8c%e6%ad%a5%e5%a4%8d%e5%88%b6%e4%b8%8e%e5%bc%82%e6%ad%a5%e5%a4%8d%e5%88%b6" aria-label="同步复制与异步复制">同步复制与异步复制</a></li>
                    <li>
                        <a href="#%e8%ae%be%e7%bd%ae%e6%96%b0%e4%bb%8e%e5%ba%93" aria-label="设置新从库">设置新从库</a></li>
                    <li>
                        <a href="#%e5%a4%84%e7%90%86%e8%8a%82%e7%82%b9%e5%ae%95%e6%9c%ba" aria-label="处理节点宕机">处理节点宕机</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%8e%e5%ba%93%e5%a4%b1%e6%95%88%e8%bf%bd%e8%b5%b6%e6%81%a2%e5%a4%8d" aria-label="从库失效：追赶恢复">从库失效：追赶恢复</a></li>
                    <li>
                        <a href="#%e4%b8%bb%e5%ba%93%e5%a4%b1%e6%95%88%e6%95%85%e9%9a%9c%e5%88%87%e6%8d%a2" aria-label="主库失效：故障切换">主库失效：故障切换</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%a4%8d%e5%88%b6%e6%97%a5%e5%bf%97%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="复制日志的实现">复制日志的实现</a><ul>
                            
                    <li>
                        <a href="#%e5%9f%ba%e4%ba%8e%e8%af%ad%e5%8f%a5%e7%9a%84%e5%a4%8d%e5%88%b6" aria-label="基于语句的复制">基于语句的复制</a></li>
                    <li>
                        <a href="#%e4%bc%a0%e8%be%93%e9%a2%84%e5%86%99%e5%bc%8f%e6%97%a5%e5%bf%97wal" aria-label="传输预写式日志（WAL）">传输预写式日志（WAL）</a></li>
                    <li>
                        <a href="#%e9%80%bb%e8%be%91%e6%97%a5%e5%bf%97%e5%a4%8d%e5%88%b6%e5%9f%ba%e4%ba%8e%e8%a1%8c" aria-label="逻辑日志复制（基于行）">逻辑日志复制（基于行）</a></li>
                    <li>
                        <a href="#%e5%9f%ba%e4%ba%8e%e8%a7%a6%e5%8f%91%e5%99%a8%e7%9a%84%e5%a4%8d%e5%88%b6" aria-label="基于触发器的复制">基于触发器的复制</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%a4%8d%e5%88%b6%e5%bb%b6%e8%bf%9f%e9%97%ae%e9%a2%98" aria-label="复制延迟问题">复制延迟问题</a><ul>
                            
                    <li>
                        <a href="#%e8%af%bb%e5%b7%b1%e4%b9%8b%e5%86%99" aria-label="读己之写">读己之写</a></li>
                    <li>
                        <a href="#%e5%8d%95%e8%b0%83%e8%af%bb" aria-label="单调读">单调读</a></li>
                    <li>
                        <a href="#%e4%b8%80%e8%87%b4%e5%89%8d%e7%bc%80%e8%af%bb" aria-label="一致前缀读">一致前缀读</a></li>
                    <li>
                        <a href="#%e5%a4%8d%e5%88%b6%e5%bb%b6%e8%bf%9f%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="复制延迟的解决方案">复制延迟的解决方案</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h1 id="第五章数据复制">第五章：数据复制<a hidden class="anchor" aria-hidden="true" href="#第五章数据复制">#</a></h1>
<p><img loading="lazy" src="https://s2.loli.net/2023/09/21/ikpqYsOJLtHuv5x.png" alt="DDIA5-1.png"  />
</p>
<p>复制的目的：<br>
● 使得数据与用户在地理上接近（从而减少延迟）<br>
● 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）<br>
● 伸缩可以接受读请求的机器数量（从而提高读取吞吐量）</p>
<p>如果复制的数据不会随时间而改变，那复制就很简单：复制一次即可。
复制的难点在于复制数据的变更。
三种流行的变更复制算法：<br>
● 单领导者<br>
● 多领导者<br>
● 无领导者</p>
<p>复制时的权衡：使用同步复制还是异步复制？如何处理失败的副本？</p>
<h2 id="领导者与追随者">领导者与追随者<a hidden class="anchor" aria-hidden="true" href="#领导者与追随者">#</a></h2>
<p>● 存储数据库副本的每个节点称为 副本（replica）。<br>
● 多副本的问题：如何确保数据都落在了所有的副本上。<br></p>
<ol>  ○ 每次对数据库的写入都要传播到所有副本上，否则副本就会有不一样的数据。<br></ol> 
<ol>  ○ 常见的解决方案：基于领导者的复制（主从复制）。</ol> 
<p>主从复制工作原理：</p>
<ol>
<li>副本之一被指定为领导者（leader，也被称作主库）<br></li>
</ol>
<ol>  a. 客户端写数据时，要把请求发送给领导者；</ol>
<ol>  b. 领导者把新输入写入本地存储。</ol>
2. 其他副本被称为追随者（followers，也被称作只读副本、从库、热备）
<ol>  a. 每当领导者将新数据写入本地存储时，他会把数据变更发送给所有的追随者，称之为复制日志或变更流。</ol>
<ol>  b. 每个追随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。</ol>
3. 当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。 但只有领导者才能接受写操作（从客户端的角度来看从库都是只读的）。
<p><img loading="lazy" src="https://s2.loli.net/2023/09/21/2f6ebcLQFJCI9u1.png" alt="DDIA5-2.png"  />
</p>
<h3 id="同步复制与异步复制">同步复制与异步复制<a hidden class="anchor" aria-hidden="true" href="#同步复制与异步复制">#</a></h3>
<p>复制系统的一个重要细节是：复制是 同步（synchronously） 发生还是 异步（asynchronously） 发生。
以用户更新头像为例：
<img loading="lazy" src="https://s2.loli.net/2023/09/21/3X8hkWtrxfmLojD.png" alt="DDIA5-3.png"  />

● 从库 1 的复制是同步的
● 从库 2 的复制是异步的</p>
<p>同步复制：
● 优点：从库保证和主库一直的最新数据副本
● 缺点：如果从库没有响应（如已崩溃、网络故障），主库就无法处理写入操作。主库必须阻止所有的写入，等待副本再次可用。</p>
<p>半同步：通常使用一个从库与主库是同步的，而其他从库是异步的。这保证了至少两个节点拥有最新的数据副本。</p>
<p>通常情况下，基于领导者的复制都配置为完全异步。注意，主库故障可能导致丢失数据。</p>
<h3 id="设置新从库">设置新从库<a hidden class="anchor" aria-hidden="true" href="#设置新从库">#</a></h3>
<p>有时会增加一个新的从库。</p>
<p>过程：</p>
<ol>
<li>在某个时刻获取主库的一致性快照（如果可能），而不必锁定整个数据库。大多数数据库都具有这个功能，因为它是备份必需的。对于某些场景，可能需要第三方工具，例如MySQL的innobackupex 。</li>
<li>将快照复制到新的从库节点。</li>
<li>从库连接到主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。该位置有不同的名称：例如，PostgreSQL将其称为 日志序列号（log sequence number, LSN），MySQL将其称为 二进制日志坐标（binlog coordinates）。</li>
<li>当从库处理完快照之后积压的数据变更，我们说它 赶上（caught up） 了主库。现在它可以继续处理主库产生的数据变化了。</li>
</ol>
<h3 id="处理节点宕机">处理节点宕机<a hidden class="anchor" aria-hidden="true" href="#处理节点宕机">#</a></h3>
<p>我们的目标：即使个别节点失效，也要能保持整个系统运行，并尽可能控制节点停机带来的影响。</p>
<h4 id="从库失效追赶恢复">从库失效：追赶恢复<a hidden class="anchor" aria-hidden="true" href="#从库失效追赶恢复">#</a></h4>
<p>● 从库可以从日志知道，在发生故障前处理的最后一个事务。
● 所以从库可以连接到主库，并拉取断开连接后的所有数据变更。
● 应用完成所有变更之后，它就赶上了主库，继续接收数据变更流。</p>
<h4 id="主库失效故障切换">主库失效：故障切换<a hidden class="anchor" aria-hidden="true" href="#主库失效故障切换">#</a></h4>
<p>● 故障切换：需要把一个从库提升为新的主库，重新配置客户端，其他从库需要开始拉取来自新主库的变更。
● 故障切换可以手动或者自动进行。</p>
<p>自动故障切换：</p>
<ol>
<li>确认主库失效。有很多事情可能会出错：崩溃，停电，网络问题等等。没有万无一失的方法来检测出现了什么问题，所以大多数系统只是简单使用 超时（Timeout） ：节点频繁地相互来回传递消息，并且如果一个节点在一段时间内（例如30秒）没有响应，就认为它挂了（因为计划内维护而故意关闭主库不算）。</li>
<li>选择一个新的主库。这可以通过选举过程（主库由剩余副本以多数选举产生）来完成，或者可以由之前选定的控制器节点（controller node） 来指定新的主库。主库的最佳人选通常是拥有旧主库最新数据副本的从库（最小化数据损失）。让所有的节点同意一个新的领导者，是一个共识问题，将在第九章详细讨论。</li>
<li>重新配置系统以启用新的主库。客户端现在需要将它们的写请求发送给新主库（将在“请求路由”中讨论这个问题）。如果老领导回来，可能仍然认为自己是主库，没有意识到其他副本已经让它下台了。系统需要确保老领导认可新领导，成为一个从库。</li>
</ol>
<p>故障切换会出现很多大麻烦：<br>
●  如果使用异步复制，则新主库可能没有收到老主库宕机前最后的写入操作。在选出新主库后，如果老主库重新加入集群，新主库在此期间可能会收到冲突的写入，那这些写入该如何处理？最常见的解决方案是简单丢弃老主库未复制的写入，这很可能打破客户对于数据持久性的期望。 <br>
●  如果数据库需要和其他外部存储相协调，那么丢弃写入内容是极其危险的操作。例如在GitHub 【13】的一场事故中，一个过时的MySQL从库被提升为主库。数据库使用自增ID作为主键，因为新主库的计数器落后于老主库的计数器，所以新主库重新分配了一些已经被老主库分配掉的ID作为主键。这些主键也在Redis中使用，主键重用使得MySQL和Redis中数据产生不一致，最后导致一些私有数据泄漏到错误的用户手中。 <br>
●  发生某些故障时（见第八章）可能会出现两个节点都以为自己是主库的情况。这种情况称为 脑裂(split brain)，非常危险：如果两个主库都可以接受写操作，却没有冲突解决机制（请参阅“多主复制”），那么数据就可能丢失或损坏。一些系统采取了安全防范措施：当检测到两个主库节点同时存在时会关闭其中一个节点[1]，但设计粗糙的机制可能最后会导致两个节点都被关闭【14】。 <br>
●  主库被宣告死亡之前的正确超时应该怎么配置？在主库失效的情况下，超时时间越长，意味着恢复时间也越长。但是如果超时设置太短，又可能会出现不必要的故障切换。例如，临时负载峰值可能导致节点的响应时间超时，或网络故障可能导致数据包延迟。如果系统已经处于高负载或网络问题的困扰之中，那么不必要的故障切换可能会让情况变得更糟糕。</p>
<h3 id="复制日志的实现">复制日志的实现<a hidden class="anchor" aria-hidden="true" href="#复制日志的实现">#</a></h3>
<p>基于主库的复制，底层工作有几种不同的复制方式。</p>
<h4 id="基于语句的复制">基于语句的复制<a hidden class="anchor" aria-hidden="true" href="#基于语句的复制">#</a></h4>
<p>在最简单的情况下，主库记录下它执行的每个写入请求（语句（statement））并将该语句日志发送给其从库。
问题：
● 任何调用 非确定性函数（nondeterministic） 的语句，可能会在每个副本上生成不同的值。比如 NOW(), RAND()。
● 如果语句使用了自增列（auto increment），或者依赖于数据库中的现有数据（例如，UPDATE &hellip; WHERE &lt;某些条件&gt;），则必须在每个副本上按照完全相同的顺序执行它们，否则可能会产生不同的效果。影响并发。
● 有副作用的语句（例如，触发器，存储过程，用户定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定的。</p>
<h4 id="传输预写式日志wal">传输预写式日志（WAL）<a hidden class="anchor" aria-hidden="true" href="#传输预写式日志wal">#</a></h4>
<p>第三章告诉我们，写操作通常追加到日志中：
● 对于日志结构存储引擎（SSTables 和 LSM 树），日志是主要存储位置。日志段在后台压缩，并进行垃圾回收。
● 覆盖单个磁盘块的 B 树，每次修改会先写入预写式日志（Write Ahead Log, WAL），以便崩溃后索引可以恢复到一个一致的状态。
所以，日志都是包含所有数据库写入的仅追加字节序列。可以使用完全相同的日志在另一个节点上构建副本：主库把日志发送给从库。
PostgreSQL和Oracle等使用这种复制方法。
缺点：
● 复制与存储引擎紧密耦合。
● 不可能使主库和从库上运行不同版本的数据库软件。
● 运维时如果升级软件版本，有可能会要求停机。</p>
<h4 id="逻辑日志复制基于行">逻辑日志复制（基于行）<a hidden class="anchor" aria-hidden="true" href="#逻辑日志复制基于行">#</a></h4>
<p>采用逻辑日志，可以把复制与存储逻辑分离。
关系型数据库通常以行作为粒度描述数据库写入的记录序列：
● 对于插入的行，日志包含所有列的新值；
● 对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，或者所有列的旧值。
● 对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列（至少是更新列）的新值。
优点：
● 逻辑日志与存储引擎分离，方便向后兼容。可以让领导者和跟随者运行不同版本的数据库软件。
● 对于外部应用，逻辑日志也更容易解析。比如复制到数据仓库，或者自定义索引和缓存。被称为数据变更捕获。</p>
<h4 id="基于触发器的复制">基于触发器的复制<a hidden class="anchor" aria-hidden="true" href="#基于触发器的复制">#</a></h4>
<p>● 上述复制都是数据库自己实现的。也可以自定义复制方法：数据库提供了触发器和存储过程。
● 允许数据库变更时，自动执行应用的程序代码。
● 开销更大，更容易出错。但更灵活。</p>
<h2 id="复制延迟问题">复制延迟问题<a hidden class="anchor" aria-hidden="true" href="#复制延迟问题">#</a></h2>
<p>● 主从异步同步会有延迟：导致同时对主库和从库的查询，结果可能不同。
● 因为从库会赶上主库，所以上述效应被称为「最终一致性」。
● 复制延迟可能超过几秒或者几分钟，下文是 3 个例子。</p>
<h3 id="读己之写">读己之写<a hidden class="anchor" aria-hidden="true" href="#读己之写">#</a></h3>
<p>如果用户把数据提交到了主库，但是主从有延迟，用户马上看数据的时候请求的从库，会感觉到数据丢失。</p>
<p><img loading="lazy" src="https://s2.loli.net/2023/09/21/LX768cM9oktwqvT.png" alt="DDIA5-4.png"  />
</p>
<p>此时需要「读写一致性」，也成为读己之写一致性。
技术：
● 读用户可能已经修改过的内容时，都从主库读；比如读个人资料都从主库读，读别人的资料可以读从库。
● 如果应用的部分内容都可能被用户编辑，上述方法无效。可以指定更新后的时间窗口，比如上次更新的一分钟内从主库读。
● 客户端记住最近一次写入的时间戳，从库提供查询时，保证该时间戳前的变更都已经传播到了本从库；否则从另外的从库读，或者等待从库追赶上来。（时间戳可以是逻辑时间戳，如日志序列号；或者要有准确的时间同步）
● 如果副本在多个数据中心，则比较复杂。任何需要从领导者提供服务的请求，都必须路由到包含主库的数据中心。
用户有多个设备时，还要考虑的问题：
● 记录更新时间戳变得更困难；
● 不同设备可能路由到不同的数据中心。如果你的方法需要读主库，就需要把同一用户的请求路由到同一个数据中心。</p>
<h3 id="单调读">单调读<a hidden class="anchor" aria-hidden="true" href="#单调读">#</a></h3>
<p>用户可能会遇到时光倒流。
第一次请求到从库看到了评论，第二次请求到另外一个从库发现评论消失。</p>
<p><img loading="lazy" src="https://s2.loli.net/2023/09/21/b7sfOBMEXC2aHP8.png" alt="DDIA5-5.png"  />
</p>
<p>单调读保证了这种异常不会发生。
方法：
● 确保每个用户总是从同一副本来读取。比如基于用户 ID 的散列来选择副本，而不是随机选。
● 但是如果该副本失败，则需要路由到另一个副本。</p>
<h3 id="一致前缀读">一致前缀读<a hidden class="anchor" aria-hidden="true" href="#一致前缀读">#</a></h3>
<p>一系列事件可能出现前后顺序不一致问题。比如回答可能在提问之前发生。
这是分区（分片）数据库中的一个特殊问题：不同分区之间独立，不存在全局写入顺序。</p>
<p><img loading="lazy" src="https://s2.loli.net/2023/09/21/pdc5VADvR2nks8e.png" alt="DDIA5-6.png"  />
</p>
<p>需要「一致前缀读」。
方法：
● 任何因果相关的写入都写入相同的分区。</p>
<h3 id="复制延迟的解决方案">复制延迟的解决方案<a hidden class="anchor" aria-hidden="true" href="#复制延迟的解决方案">#</a></h3>
<p>● 可以信赖数据库：需要事务。
● 事务（transaction） 存在的原因：数据库通过事务提供强大的保证，所以应用程序可以更加简单。
● 单节点事务存在了很长时间，但是分布式数据库中，许多系统放弃了事务。“因为事务的代价太高。”
● 本书的其余部分将继续探讨事务。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://csqread.top/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">数据密集型系统设计</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://csqread.top/posts/tech/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E8%AE%A1%E5%88%92/">
    <span class="title">« 上一页</span>
    <br>
    <span>深入理解Java虚拟机系列读书笔记计划</span>
  </a>
  <a class="next" href="https://csqread.top/posts/tech/%E5%8F%88%E4%B8%80%E6%AC%A1%E7%9A%84%E5%88%B7%E6%9C%BA%E4%B9%8B%E6%97%85/">
    <span class="title">下一页 »</span>
    <br>
    <span>又一次的刷机之旅</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://csqread.top">Qian&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
